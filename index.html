<!DOCTYPE html>
<html>
  <head>
    <title>Random Motion Demo</title>
  </head>
  <style>
    @font-face {
      font-family: "Outfit Regular";
      src: url("Outfit-Regular.ttf") format("truetype");
    }

    :root {
      font-family: Outfit Regular;
    }

    body {
      margin: 0;
      width: 100vw;
      min-height: 100vh;

      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
    }
    #canvas {
      border: 1px solid black;
    }
    #control button {
      margin: 0 0.5rem 0 0.5rem;
    }
    #counter {
      text-align: center;
    }
    #counter h3 {
      margin: 0;
    }
  </style>
  <body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="control">
      <button id="slow-down" disabled><<</button>
      Ã—<span id="multiplier">1</span>
      <button id="speed-up">>></button>
    </div>
    <div id="counter">
      <h3>Time Elapsed</h3>
      <span id="elapsed-min">00</span>:<span id="elapsed-sec">00</span>
    </div>

    <script>
      const CANVAS_WIDTH = 800;
      const CANVAS_HEIGHT = 600;
      const NUM_ENTITIES = 3;
      const COLOURS = ["blue", "red", "green"];
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      class Circle {
        static defaultSpeed = 5;
        static defaultRadius = 20;
        constructor(x, y, speedX, speedY, colour = "red") {
          this.radius = Circle.defaultRadius;
          this.speedX = speedX;
          this.speedY = speedY;
          this.x = x;
          this.y = y;
          this.colour = colour;
        }

        static generateRandomX() {
          return (
            Math.floor(
              Math.random() * (CANVAS_WIDTH - 2 * Circle.defaultRadius)
            ) + Circle.defaultRadius
          );
        }

        static generateRandomY() {
          return (
            Math.floor(
              Math.random() * (CANVAS_HEIGHT - 2 * Circle.defaultRadius)
            ) + Circle.defaultRadius
          );
        }

        static generateRandomSpeed() {
          const speedX = (Math.random() < 0.5 ? 1 : -1) * Math.random() * 5;
          const speedY =
            (Math.random() < 0.5 ? 1 : -1) *
            Math.sqrt(Circle.defaultSpeed ** 2 - speedX ** 2);
          return [speedX, speedY];
        }

        hasCollidedWith(otherCircle) {
          // Checking for collision, with an additional threshold variable
          const additionalThreshold = 0;
          return (
            (this.x - otherCircle.x) ** 2 + (this.y - otherCircle.y) ** 2 <=
            (this.radius + otherCircle.radius + additionalThreshold) ** 2
          );
        }

        move() {
          this.x += this.speedX;
          this.y += this.speedY;
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fillStyle = this.colour;
          ctx.fill();
          ctx.closePath();
        }
      }

      // Creating circle entities
      //   const entities = [
      //     new Circle(400 + 40 * Math.sin(Math.PI / 3), 280, -1, 1, "red"),
      //     new Circle(400 - 40 * Math.sin(Math.PI / 3), 280, 1, 1, "blue"),
      //     new Circle(400, 300 + 40, 0, -1, "green"),
      //   ];
      const entities = [];
      for (let i = 0; i < NUM_ENTITIES; i++) {
        const [speedX, speedY] = Circle.generateRandomSpeed();
        const circle = new Circle(
          Circle.generateRandomX(),
          Circle.generateRandomY(),
          speedX,
          speedY,
          COLOURS[i % COLOURS.length]
        );

        for (let j = 0; j < entities.length; j++) {
          if (!circle.hasCollidedWith(entities[j])) {
            continue;
          }
          circle.x = Circle.generateRandomX();
          circle.y = Circle.generateRandomY();
          j = 0;
        }
        entities.push(circle);
      }

      // Setting speed control event listeners
      let currMultiplier = 1;
      const MIN_MULTIPLIER = 1;
      const MAX_MULTIPLIER = 5;
      const speedUpBtn = document.getElementById("speed-up");
      const slowDownBtn = document.getElementById("slow-down");
      const multiplierEle = document.getElementById("multiplier");

      const updateSpeed = (prevMulti, currMulti) => {
        for (ent of entities) {
          ent.speedX *= currMulti / prevMulti;
          ent.speedY *= currMulti / prevMulti;
        }
        multiplierEle.innerHTML = currMulti;
      };

      speedUpBtn.addEventListener("click", () => {
        const prevMultiplier = currMultiplier;
        currMultiplier += 1;
        updateSpeed(prevMultiplier, currMultiplier);
        if (currMultiplier >= MAX_MULTIPLIER) {
          speedUpBtn.disabled = true;
        }
        slowDownBtn.disabled = false;
      });

      slowDownBtn.addEventListener("click", () => {
        const prevMultiplier = currMultiplier;
        currMultiplier -= 1;
        updateSpeed(prevMultiplier, currMultiplier);
        if (currMultiplier <= MIN_MULTIPLIER) {
          slowDownBtn.disabled = true;
        }
        speedUpBtn.disabled = false;
      });

      // Setting time elapsed interval
      let timeElapsed = 0;
      const minElapsedEle = document.getElementById("elapsed-min");
      const secElapsedEle = document.getElementById("elapsed-sec");
      const timeElapsedIntervalId = window.setInterval(() => {
        timeElapsed += currMultiplier;
        const secElapsedStr = (timeElapsed % 60).toString();
        const minElapsedStr = Math.floor(timeElapsed / 60).toString();
        minElapsedEle.innerHTML =
          (minElapsedStr.length === 1 ? "0" : "") + minElapsedStr;
        secElapsedEle.innerHTML =
          (secElapsedStr.length === 1 ? "0" : "") + secElapsedStr;
      }, 1000);

      const mainLoop = () => {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        for (const ent of entities) {
          ent.move();
          ent.draw();
        }

        // Checking collision with walls
        for (const ent of entities) {
          if (ent.x + ent.radius >= CANVAS_WIDTH || ent.x - ent.radius <= 0) {
            ent.speedX =
              (ent.x + ent.radius >= CANVAS_WIDTH ? -1 : 1) *
              Math.abs(ent.speedX);
          }
          if (ent.y + ent.radius >= CANVAS_HEIGHT || ent.y - ent.radius <= 0) {
            ent.speedY =
              (ent.y + ent.radius >= CANVAS_HEIGHT ? -1 : 1) *
              Math.abs(ent.speedY);
          }
        }

        // Checking collision with other circles
        let numCollisions = 0;
        for (let i = 0; i < entities.length; i++) {
          for (let j = i + 1; j < entities.length; j++) {
            const ent1 = entities[i];
            const ent2 = entities[j];
            if (!ent1.hasCollidedWith(ent2)) {
              continue;
            }
            numCollisions++;
            [ent1.speedX, ent1.speedY, ent2.speedX, ent2.speedY] = [
              ent2.speedX,
              ent2.speedY,
              ent1.speedX,
              ent1.speedY,
            ];
          }
        }

        // Terminating if all 3 spheres collide
        if (numCollisions >= 2) {
          window.clearInterval(timeElapsedIntervalId);
          return;
        }

        window.requestAnimationFrame(mainLoop);
      };

      window.requestAnimationFrame(mainLoop);
    </script>
  </body>
</html>
